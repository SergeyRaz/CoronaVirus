{"version":3,"sources":["variables.js","App.js","serviceWorker.js","index.js"],"names":["static_data","link_corona_virus","initialViewState","longitude","latitude","zoom","pitch","bearing","App","props","state","coronaJson","totalDeaths","totalConfirmed","totalCured","axios","get","then","res","coronaData","data","features","item","push","attributes","setState","this","console","log","line","ArcLayer","id","pickable","widthMinPixels","getStrokeWidth","getSourcePosition","getTargetPosition","d","Long_","Lat","getSourceColor","getTargetColor","scatter","ScatterplotLayer","opacity","stroked","filled","radiusScale","radiusMinPixels","radiusMaxPixels","lineWidthMinPixels","getPosition","getRadius","Math","sqrt","Confirmed","getFillColor","getLineColor","onHover","info","object","x","y","el","document","getElementById","chartData","datasets","Deaths","Recovered","backgroundColor","borderColor","labels","chartOptions","legend","position","boxWidth","fontColor","title","display","text","fontSize","fontStyle","elements","arc","cutoutPercentage","responsive","en","ReactDOM","render","options","style","left","top","setTooltip","controller","layers","mapStyle","mapboxApiAccessToken","React","Component","Boolean","window","location","hostname","match","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9ce386ef.chunk.js","sourcesContent":["let link_corona_virus =\r\n  'https://services1.arcgis.com/0MSEUqKaxRlEPj5g/arcgis/rest/services/ncov_cases/FeatureServer/2/query?f=json&where=Confirmed%20%3E%200&returnGeometry=false&spatialRel=esriSpatialRelIntersects&outFields=*&orderByFields=Confirmed%20desc&resultOffset=0&resultRecordCount=100&cacheHint=true';\r\n\r\nlet static_data = {\r\n  link_corona_virus,\r\n};\r\n\r\nexport default static_data;\r\n","import ReactDOM from 'react-dom';\r\nimport static_data from './variables';\r\nimport './App.css';\r\nimport React from 'react';\r\nimport { StaticMap } from 'react-map-gl';\r\nimport DeckGL, { ScatterplotLayer } from 'deck.gl';\r\nimport { ArcLayer } from '@deck.gl/layers';\r\nimport axios from 'axios';\r\nimport { Pie } from 'react-chartjs-2';\r\n\r\n// Set your mapbox access token here\r\nconst MAPBOX_ACCESS_TOKEN =\r\n  'pk.eyJ1IjoiYWtvemxvdiIsImEiOiJjazZiMDJheGowZDNiM250aXcyZnZ6YXJyIn0.J5Hj_OvUO9aaD1fk6rzUCg';\r\n\r\n// Initial viewport settings\r\nconst initialViewState = {\r\n  longitude: 114.3055,\r\n  latitude: 30.5928,\r\n  zoom: 3,\r\n  pitch: 30,\r\n  bearing: 0,\r\n};\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      coronaJson: null,\r\n      totalDeaths: null,\r\n      totalConfirmed: null,\r\n      totalCured: null,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    axios\r\n      .get(static_data.link_corona_virus)\r\n      .then(res => {\r\n        let coronaData = [];\r\n        for (let item of res.data.features) {\r\n          coronaData.push(item.attributes);\r\n        }\r\n        // return coronaData;\r\n        this.setState({\r\n          coronaJson: coronaData,\r\n          // totalDeaths: 'jkkhj', //res.data.data.totalDeaths,\r\n          // totalConfirmed: 'fghjh', //res.data.data.totalConfirmed,\r\n          // totalCured: 'ghjfgj', //res.data.data.cured,\r\n        });\r\n      })\r\n      .then(res => {});\r\n  }\r\n  render() {\r\n    let data = this.state.coronaJson;\r\n    console.log(data);\r\n    const line = [\r\n      new ArcLayer({\r\n        id: 'great-circle-layer',\r\n        data,\r\n        pickable: false,\r\n        widthMinPixels: 1,\r\n        getStrokeWidth: 12,\r\n        getSourcePosition: [114.3055, 30.5928],\r\n        getTargetPosition: d => [d.Long_, d.Lat],\r\n        getSourceColor: [248, 67, 67],\r\n        getTargetColor: [248, 174, 67],\r\n      }),\r\n    ];\r\n    const scatter = new ScatterplotLayer({\r\n      id: 'scatterplot-layer',\r\n      data,\r\n      pickable: true,\r\n      opacity: 0.7,\r\n      stroked: true,\r\n      filled: true,\r\n      radiusScale: 1000,\r\n      radiusMinPixels: 8,\r\n      radiusMaxPixels: 50,\r\n      lineWidthMinPixels: 1,\r\n      getPosition: d => [d.Long_, d.Lat],\r\n      getRadius: d => Math.sqrt(d.Confirmed),\r\n      getFillColor: d => [255, 140, 0],\r\n      getLineColor: d => [0, 0, 0],\r\n      onHover: info => setTooltip(info.object, info.x, info.y, this.state),\r\n      // onClick: info => setTooltip(info.object, info.x, info.y, this.state),\r\n    });\r\n    return (\r\n      <div>\r\n        <div id=\"tooltip\"></div>\r\n        <DeckGL\r\n          initialViewState={initialViewState}\r\n          controller={true}\r\n          layers={[line, scatter]}\r\n        >\r\n          {/* <div className=\"corona-total\">\r\n            <div className=\"total-deaths\">\r\n              Total Deaths - {this.state.totalDeaths}\r\n            </div>\r\n            <div className=\"total-confirmed\">\r\n              Total Confirmed - {this.state.totalConfirmed}\r\n            </div>\r\n            <div className=\"total-cured\">\r\n              Total Cured - {this.state.totalCured}\r\n            </div>\r\n          </div> */}\r\n          <StaticMap\r\n            mapStyle=\"mapbox://styles/mapbox/dark-v9\"\r\n            mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN}\r\n          ></StaticMap>\r\n        </DeckGL>\r\n      </div>\r\n    );\r\n  }\r\n}\r\nfunction setTooltip(object, x, y, state) {\r\n  const el = document.getElementById('tooltip');\r\n  if (object) {\r\n    let chartData = {\r\n      datasets: [\r\n        {\r\n          data: [object.Confirmed, object.Deaths, object.Recovered],\r\n          backgroundColor: [\r\n            'rgba(255, 206, 86, 0.5)',\r\n            'rgba(255, 99, 132, 0.5)',\r\n            'rgba(11,123,59, 0.5)',\r\n          ],\r\n          borderColor: [\r\n            'rgba(255, 255, 255, 1)',\r\n            'rgba(255, 255, 255, 1)',\r\n            'rgba(255, 255, 255, 1)',\r\n          ],\r\n        },\r\n      ],\r\n      labels: ['Confirmed', 'Deaths', 'Recovered'],\r\n    };\r\n\r\n    let chartOptions = {\r\n      legend: {\r\n        position: 'right',\r\n        labels: {\r\n          boxWidth: 20,\r\n          fontColor: '#fff',\r\n        },\r\n      },\r\n      title: {\r\n        display: true,\r\n        text: '',\r\n        fontColor: '#fff',\r\n        fontSize: 16,\r\n        fontStyle: 'normal',\r\n      },\r\n      elements: {\r\n        arc: {\r\n          // borderWidth: 18,\r\n        },\r\n      },\r\n      cutoutPercentage: 30,\r\n      responsive: true,\r\n    };\r\n\r\n    chartOptions.title.text = object.en;\r\n    if (object.Confirmed) {\r\n      chartData.labels[0] = `Confirmed - ${object.Confirmed}`;\r\n    }\r\n    if (object.Deaths) {\r\n      chartData.labels[1] = `Deaths - ${object.Deaths}`;\r\n    }\r\n    if (object.Recovered) {\r\n      chartData.labels[2] = `Cured - ${object.Recovered}`;\r\n    }\r\n\r\n    ReactDOM.render(<Pie data={chartData} options={chartOptions} />, el);\r\n    el.style.display = 'block';\r\n    el.style.left = x + 'px';\r\n    el.style.top = y + 'px';\r\n  } else {\r\n    el.style.display = 'none';\r\n  }\r\n}\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}